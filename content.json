{"meta":{"title":"酸甜瓜","subtitle":null,"description":"一路高歌猛进是电视剧，一地鸡毛才是生活","author":"suantiangua","url":"https://github.com/lvdouzhou/lvdouzhou.github.io.git"},"pages":[{"title":"404","date":"2017-08-16T03:32:45.466Z","updated":"2017-08-16T03:32:45.466Z","comments":true,"path":"404.html","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/404.html","excerpt":"","text":"公益404页面"},{"title":"","date":"2017-08-16T06:53:22.786Z","updated":"2017-08-16T06:53:22.786Z","comments":true,"path":"about/index.html","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/about/index.html","excerpt":"","text":"关于我我是一个修炼了两年的 Android 程序猿。 联系我GitHub: https://github.com/lvdouzhou邮箱： lvdouzhou0712@qq.com"},{"title":"我的知识体系架构图","date":"2017-08-16T07:44:48.437Z","updated":"2017-08-16T07:44:48.437Z","comments":true,"path":"knowledge/index.html","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/knowledge/index.html","excerpt":"","text":"Android 应用层Android 性能优化其他技能"},{"title":"tags","date":"2017-06-21T07:45:46.000Z","updated":"2017-08-15T07:23:02.074Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"android 屏幕各尺寸获取","slug":"android 屏幕各尺寸获取","date":"2017-09-05T09:18:29.000Z","updated":"2017-09-05T09:21:45.000Z","comments":true,"path":"2017/09/05/android 屏幕各尺寸获取/","link":"","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/2017/09/05/android 屏幕各尺寸获取/","excerpt":"","text":"在开发中我们会遇到各种需要获得屏幕参数的场景，当中也有不少坑，所以现在就记录一下这些参数的获取方式。以免再入坑。 物理屏幕宽高一、底部没有虚拟按键 这里获取到的宽高，就是你眼睛能看到的，屏幕亮着的地方的宽高。1234567891011121314151617181920212223242526/** * 获取屏幕的宽 * * @param context * @return */public static int getScreenWidth(Context context) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); DisplayMetrics dm = new DisplayMetrics(); wm.getDefaultDisplay().getMetrics(dm); return dm.widthPixels;&#125;/** * 获取屏幕的高度 * * @param context * @return */public static int getScreenHeight(Context context) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); DisplayMetrics dm = new DisplayMetrics(); wm.getDefaultDisplay().getMetrics(dm); return dm.heightPixels;&#125; 二、底部有虚拟按键华为手机底部都会有一个黑色的虚拟按键(NavigationBar)，通过上面这个方式得到的屏幕高度是屏幕真是高度-虚拟按键的高度。所以有虚拟按键的情况获取屏幕的高度就是另一种方法了。12345678910111213141516171819202122232425 public static int getRealHeight(Context context) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); Display display = wm.getDefaultDisplay(); int screenHeight = 0; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; DisplayMetrics dm = new DisplayMetrics(); display.getRealMetrics(dm); screenHeight = dm.heightPixels; //或者也可以使用getRealSize方法// Point size = new Point();// display.getRealSize(size);// screenHeight = size.y; &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; try &#123; screenHeight = (Integer) Display.class.getMethod(&quot;getRawHeight&quot;).invoke(display); &#125; catch (Exception e) &#123; DisplayMetrics dm = new DisplayMetrics(); display.getMetrics(dm); screenHeight = dm.heightPixels; &#125; &#125; return screenHeight; &#125; 虚拟按键高度虚拟按键(NavigationBar)高度可以通过读取定义在Android系统尺寸资源中的 navigation_bar_height 获得。所以不管虚拟按键是显示还是隐藏，得到的结果都是一样的。123456789public static int getNavigationBarHeight(Context context) &#123; int navigationBarHeight = -1; Resources resources = context.getResources(); int resourceId = resources.getIdentifier(&quot;navigation_bar_height&quot;,&quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) &#123; navigationBarHeight = resources.getDimensionPixelSize(resourceId); &#125; return navigationBarHeight;&#125; 状态栏高度状态栏就是屏幕顶部显示时间，电池，wifi 等信息的栏目。 方法一：系统提供了一个Resource类，通过这个类可以获取资源文件，借此可以获取 到status_bar_height 。 123456789public int getStatusBarHeight() &#123; int result = 0; int resourceId = getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) &#123; result = getResources().getDimensionPixelSize(resourceId); &#125; return result;&#125; 方法2： 通过反射Android的所有资源都会有惟一标识在R类中作为引用。我们也可以通过反射获取R类的实例域，然后找 status_bar_height。 12345678910111213public void getStatusBarHeightByReflect() &#123; int statusBarHeight2 = -1; try &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.android.internal.R$dimen&quot;); Object object = clazz.newInstance(); int height = Integer.parseInt(clazz.getField(&quot;status_bar_height&quot;) .get(object).toString()); statusBarHeight2 = getResources().getDimensionPixelSize(height); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Log.e(TAG, &quot;状态栏高度-反射方式：&quot; + statusBarHeight2);&#125; 借助应用区 top 属性。状态栏位于屏幕的最顶端，坐标从 (0,0) 开始，所以应用区的顶部的位置就是状态栏的高度。 123456789101112/** * 应用区的顶端位置即状态栏的高度 * *注意*该方法不能在初始化的时候用 * */public void getStatusBarHeightByTop() &#123; Rect rectangle = new Rect(); getWindow().getDecorView().getWindowVisibleDisplayFrame(rectangle); Log.e(TAG, &quot;状态栏高度-应用区顶部:&quot; + rectangle.top);&#125; 应用区域高度除去状态栏剩下的都时应用区。由此可知屏幕的高度 - 状态栏高度 = 应用区的高度。 123456789101112131415/** * 不能在 onCreate 方法中使用。 * 因为这种方法依赖于WMS（窗口管理服务的回调）。正是因为窗口回调机制，所以在Activity初始化时执行此方法得到的高度是0。 * 这个方法推荐在回调方法onWindowFocusChanged()中执行，才能得到预期结果。 */ public void getAppViewHeight()&#123; //屏幕 DisplayMetrics dm = new DisplayMetrics(); getWindowManager().getDefaultDisplay().getMetrics(dm); //应用区域 Rect outRect1 = new Rect(); getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect1); int statusBar = dm.heightPixels - outRect1.height(); //状态栏高度=屏幕高度-应用区域高度 Log.e(TAG, &quot;应用区高度:&quot; + statusBar); &#125; setContentView 高度，view 显示的高度需要在见面创建后才能获取到。 12345public static int getContentViewHeight(Activity activity) &#123; Rect rectangle= new Rect(); activity.getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(rectangle); return rectangle.height(); &#125; 标题栏高度标题栏高度 = 应用区高度 - view 显示高度123456789 public static void getTitleBarHeight(Activity activity) &#123; Rect outRect1 = new Rect(); activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect1); int viewTop = activity.getWindow().findViewById(Window.ID_ANDROID_CONTENT).getTop(); //要用这种方法 int titleBarH = viewTop - outRect1.top; Log.e(TAG, &quot;标题栏高度-计算:&quot; + titleBarH);&#125;","categories":[{"name":"“android” ,“android 屏幕尺寸”","slug":"“android”-“android-屏幕尺寸”","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/categories/“android”-“android-屏幕尺寸”/"}],"tags":[{"name":"android","slug":"android","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/tags/android/"}]},{"title":"","slug":"UML 类图学习笔记","date":"2017-09-05T09:17:54.779Z","updated":"2017-09-05T09:17:54.779Z","comments":true,"path":"2017/09/05/UML 类图学习笔记/","link":"","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/2017/09/05/UML 类图学习笔记/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"正则表达式","slug":"正则表达式","date":"2017-08-17T01:43:16.000Z","updated":"2017-08-18T03:51:07.000Z","comments":true,"path":"2017/08/17/正则表达式/","link":"","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/2017/08/17/正则表达式/","excerpt":"基本正则表达式是使用你定义的“规则”扫描目标字符串，寻找目标字符串中与“规则”相匹配的字符串。在线练习正则表达式 123规则: ab目标字符串: abcde结果：ab 在 abcde 中查找，是否有 ab 这个字符串。 注：正则表达式大小写敏感的","text":"基本正则表达式是使用你定义的“规则”扫描目标字符串，寻找目标字符串中与“规则”相匹配的字符串。在线练习正则表达式 123规则: ab目标字符串: abcde结果：ab 在 abcde 中查找，是否有 ab 这个字符串。 注：正则表达式大小写敏感的 元字符元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思 元字符 描述 . 句号匹配任意单个字符除了换行符 [ ] 字符种类. 匹配方括号内的任意字符 [^ ] 否定的字符种类. 匹配除了方括号里的任意字符 * 匹配 &gt;=0 个重复字符串 + 匹配 &gt;=1 个重复字符串 ? 标记?之前的字符为可选 {n,m} 匹配num个中括号之前的字符 (n &lt;= num &lt;= m) (xyz) 字符集, 匹配与 xyz 完全相等的字符串 “\\ “ 或运算符,匹配符号前或后的字符 \\ 转义字符,用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \\ ^ 从开始行开始匹配 $ 从末端开始匹配 点运算符 “.”栗子：匹配一个任意字符后面跟着是b和c的字符串.123规则: .bc目标字符串: abcde结果：abc 字符集 [ ]字符集也叫做字符类. 方括号用来指定一个字符集. 在方括号中使用连字符来指定字符集的范围. 在方括号中的字符集不关心顺序 栗子：匹配包含 b 或者 c 的字符串 1234567891011栗子1：规则: [bc]目标字符串: 456abc123de结果： b 、 c注：得到的结果 b 和 c 是两个结果栗子2：规则: [0-9]目标字符串: abc123de结果： 1、 2 、 3注： 1 2 3 分别是三个结果 否定字符集一般来说 ^ 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的. 栗子：匹配一个后面跟着de的除了c的任意字符.123规则: [^a]de目标字符串: abcdeade结果： cde 重复次数*号， &gt;=0 次123规则: [a-z]*bc目标字符串: Abc abc结果： bc 、 abc *号匹配 在*之前的字符出现大于等于0次。表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串 +号， &gt;=1 次123规则: [a-z]*bc目标字符串: Abc abc结果： abc ?号， 出现 0 或 1 次123规则: [a-z]*bc目标字符串: Abc abc结果： bc 、 abc { } 号在正则表达式中 {} 是一个量词, 常用来一个或一组字符可以重复出现的次数. 例如, 表达式 [0-9]{2,3} 匹配 2～3 位 0～9 的数字.12345678910111213141516171819栗子1：3~4位规则: [0-9]&#123;3,4&#125;目标字符串:12345adbc666结果： 1234、666栗子2：2~3位规则: [0-9]&#123;2,3&#125;目标字符串:12345adbc666结果： 123、45、666栗子3：至少出现4位规则: [0-9]&#123;4,&#125;目标字符串:12345adbc666结果： 12345栗子3：只出现3位规则: [0-9]&#123;3,&#125;目标字符串:12345adbc666结果： 123、666 (…) 特征标志群特征标群是一组写在 (…) 中的子模式. 例如之前说的 {} 是用来表示前面一个字符出现指定次数. 但如果在 {} 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 (ab)* 匹配连续出现 0 或更多个 ab.1234栗子： 出现 0 次 或者更多个 连续的3个6规则: (666)*目标字符串:666abc12dd6666结果： 666 | 或运算1234栗子： 匹配后面跟着 b 的 A 或者 a 开头的字符串规则: (A|a)b目标字符串:abc78Abcdb7结果： ab、Ab 转码特殊字符1234栗子： 匹配 ?b 规则: \\?b目标字符串:bc78A?bcdb7结果： ?b 锚点^ 指定开头, $ 指定结尾。123456789栗子： 必须是 a 开头规则: ^(A)b目标字符串: Abc66 abc结果： Ab栗子： 必须是 bc. 结尾规则: (bc\\.)$目标字符串: Abc66 abc.结果： bc. 正则表达式图片总结","categories":[{"name":"“正则表达式”","slug":"“正则表达式”","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/categories/“正则表达式”/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/tags/正则表达式/"}]},{"title":"MarkDown 语法学习","slug":"markdown 语法学习","date":"2017-08-16T09:06:11.000Z","updated":"2017-08-16T09:54:18.000Z","comments":true,"path":"2017/08/16/markdown 语法学习/","link":"","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/2017/08/16/markdown 语法学习/","excerpt":"段落与换行 段落的前后必须是空行 ( 空行指的是行内什么都没有，或者只有空白符（空格或制表符）) 如果需要在段落内加入换行’&lt; b r &gt; ‘： 栗子： 1梅西什么时候去皇马啊？&lt;br&gt; 给钱都不去","text":"段落与换行 段落的前后必须是空行 ( 空行指的是行内什么都没有，或者只有空白符（空格或制表符）) 如果需要在段落内加入换行’&lt; b r &gt; ‘： 栗子： 1梅西什么时候去皇马啊？&lt;br&gt; 给钱都不去 标题1.Setext 形式 12345类型1： 标题一 =====类型2： 标题一 ----- “=”、”-“ 的个数没有限制，但是最好是和标题内容的长度一样，这样比较美观。 Setext 只支持这两种类型的标题 2.atx 形式 1234类型1： 对称的 # 包括文本 #### h4 ####类型2： 左边有 # #### h4 注意：# 和文字之间要有一个空格 引用1.单行引用1栗子： &gt; 梅西什么时候去皇马啊？ 给钱都不去 注意：如果仅在第一行使用 &gt;，后面相邻的行即使省略 &gt;，也会变成引用内容。留一行空行就能取消引用。 2.嵌套引用123栗子： &gt; 梅西什么时候去皇马啊？ &gt;&gt; 给钱都不去 列表1.无序列表1234栗子： + 梅西什么时候去皇马啊？ * 梅西什么时候去皇马啊？ - 梅西什么时候去皇马啊？ 2.有序列表1231. 有序列表以数字和 `.` 开始；3. 数字的序列并不会影响生成的列表序列；4. 但仍然推荐按照自然顺序（1.2.3...）编写。 3.嵌套的列表1234567栗子： 1.第一层 + 1-1 + 1-1-1 + 1-2 + 1-2-1 4.其他123451.无序列表项的开始是：符号 空格；2.有序列表项的开始是：数字 . 空格；3.空格至少为一个，多个空格将被解析为一个；4.如果仅需要在行前显示数字和 .： 可以使用：数字\\. 来取消显示为列表 注：“\\*” 的语法专门用来显示 Markdown 语法中使用的特殊字符 引入代码1.使用 12栗子： prinf(&quot;hello&quot;); 2.使用 tab 键开头，或者使用四个空格开头。 分割线123栗子： *** --- 超链接 行内式(1) 普通连接1[百度](htt://www.baidu.com/) (2) 指向本地文件1[本地文件](./images/icon.png) (3) 包含 title1[Google](http://www.google.com/ &quot;Google&quot;) 参考式参考式链接的写法相当于行内式拆分成两部分，并通过一个 识别符 来连接两部分。参考式能尽量保持文章结构的简单，也方便统一管理 URL123[Google][link][link]: http://www.google.com/ &quot;Google&quot; link 就相当于识别符，链接内容的定义可以放在同一个文件的 任意位置。 自动链接1&lt;http://www.baidu.com/&gt; 插入图片 直接使用超链接的方法插入图片,不同的是需要在前面加上一个 !。也分为参考式、行内式。 1![GitHub](www.baidu.com &quot;图片标题&quot;) 指定图片的显示大小 1&lt;img src=&quot;www.baidu.com&quot; alt=&quot;GitHub&quot; title=&quot;图片标题&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt; 强调 斜体 123_1111_*2222* 加粗 12**dd**__666__ 字符串转义反斜线（\\）用于插入在 Markdown 语法中有特殊作用的字符。","categories":[{"name":"“MarkDown”","slug":"“MarkDown”","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/categories/“MarkDown”/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/tags/MarkDown/"}]},{"title":"Hexo-Next的背景动态效果和心心","slug":"Hexo-Next的背景动态效果和心心","date":"2017-06-21T08:33:28.000Z","updated":"2017-08-16T09:11:54.924Z","comments":true,"path":"2017/06/21/Hexo-Next的背景动态效果和心心/","link":"","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/2017/06/21/Hexo-Next的背景动态效果和心心/","excerpt":"1.主题使用的是 Next 。先下载 love.js 和 particle.js123js 文件下载地址 http://7u2ss1.com1.z0.glb.clouddn.com/love.jshttp://7u2ss1.com1.z0.glb.clouddn.com/particle.js 如果地址无效了，可以直接复制下面代码","text":"1.主题使用的是 Next 。先下载 love.js 和 particle.js123js 文件下载地址 http://7u2ss1.com1.z0.glb.clouddn.com/love.jshttp://7u2ss1.com1.z0.glb.clouddn.com/particle.js 如果地址无效了，可以直接复制下面代码 love.js1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);particle.js 1!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e(&quot;script&quot;),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,&quot;zIndex&quot;,-1),o:n(i,&quot;opacity&quot;,.5),c:n(i,&quot;color&quot;,&quot;0,0,0&quot;),n:n(i,&quot;count&quot;,99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle=&quot;rgba(&quot;+m.c+&quot;,&quot;+(t+.2)+&quot;)&quot;,l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement(&quot;canvas&quot;),m=t(),d=&quot;c_n&quot;+m.l,l=u.getContext(&quot;2d&quot;),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText=&quot;position:fixed;top:0;left:0;z-index:&quot;+m.z+&quot;;opacity:&quot;+m.o,e(&quot;body&quot;)[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 2.把 js 文件 love.js 和 particle.js 放在 \\themes\\next\\source\\js\\src 文件目录下 3.更新 \\themes\\next\\layout_layout.swig 文件，在末尾（在前面引用会出现找不到的bug）添加以下 js 引入代码： 1234&lt;!-- 背景动画 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt;&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 4.运行 hexo g , hexo s 查看效果","categories":[{"name":"“hexo 配置”","slug":"“hexo-配置”","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/categories/“hexo-配置”/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://github.com/lvdouzhou/lvdouzhou.github.io.git/tags/hexo/"}]}]}